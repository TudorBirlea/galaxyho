<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Exoplanets</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;width:100vw;height:100vh;font-family:'SF Mono','Fira Code','Consolas',monospace}
canvas{display:block;width:100%;height:100%}
#ctrl{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:6px;z-index:10;flex-wrap:wrap;justify-content:center;max-width:95vw}
.pb{padding:5px 12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.7);color:rgba(255,255,255,.55);font-family:inherit;font-size:10px;letter-spacing:.8px;cursor:pointer;border-radius:3px;transition:all .3s;text-transform:uppercase;backdrop-filter:blur(6px);white-space:nowrap}
.pb:hover{background:rgba(255,255,255,.08);color:#fff}
.pb.on{border-color:rgba(100,180,255,.5);color:#8cf;background:rgba(100,180,255,.06)}
#hud{position:fixed;top:20px;left:20px;z-index:10;color:rgba(255,255,255,.45);font-size:10px;letter-spacing:1px;line-height:2}
.hl{color:rgba(255,255,255,.25)}.hv{color:rgba(130,200,255,.8)}.hf{color:rgba(255,255,255,.3);font-style:italic;letter-spacing:.5px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
<div><span class="hl">PLANET </span><span class="hv" id="pn">TRAPPIST-1 e</span></div>
<div><span class="hl">TYPE </span><span class="hv" id="pt">Terran</span></div>
<div><span class="hf" id="pf">Earth-like · high habitability</span></div>
</div>
<div id="ctrl"></div>
<script>
const PLANETS=[
{n:'TRAPPIST-1 e',t:'Terran',f:'Earth-like · high habitability',i:0},
{n:'Kepler-442 b',t:'Desert',f:'High metals · arid super-Earth',i:1},
{n:'OGLE-2005-BLG-390L b',t:'Ice',f:'Frozen world · rare elements',i:2},
{n:'HD 189733 b',t:'Gas Giant',f:'Hot Jupiter · silicate rain',i:3},
{n:'55 Cancri e',t:'Lava',f:'Molten surface · extreme metals',i:4},
{n:'GJ 1214 b',t:'Ocean',f:'Deep global ocean · thick clouds',i:5},
{n:'J1407 b',t:'Ringed',f:'Super-Saturn · 200x ring system',i:6},
];
let targetIdx=0,currentIdx=0;
const ctrl=document.getElementById('ctrl');
PLANETS.forEach((p,i)=>{
const b=document.createElement('button');
b.className='pb'+(i===0?' on':'');b.textContent=p.t;
b.onclick=()=>{
  document.querySelectorAll('.pb').forEach(x=>x.classList.remove('on'));
  b.classList.add('on');targetIdx=p.i;
  document.getElementById('pn').textContent=p.n;
  document.getElementById('pt').textContent=p.t;
  document.getElementById('pf').textContent=p.f;
};ctrl.appendChild(b);
});

const cv=document.getElementById('c');
const gl=cv.getContext('webgl',{antialias:false,alpha:false});
function resize(){
  const d=Math.min(devicePixelRatio,2);
  cv.width=innerWidth*d;cv.height=innerHeight*d;
  gl.viewport(0,0,cv.width,cv.height);
}
addEventListener('resize',resize);resize();

let rotX=0.4,rotY=0.2,zoom=3.0,dragging=false,lastMX=0,lastMY=0;
cv.onmousedown=e=>{dragging=true;lastMX=e.clientX;lastMY=e.clientY};
cv.onmousemove=e=>{if(!dragging)return;rotX+=(e.clientX-lastMX)*.004;rotY+=(e.clientY-lastMY)*.004;rotY=Math.max(-1.5,Math.min(1.5,rotY));lastMX=e.clientX;lastMY=e.clientY};
cv.onmouseup=cv.onmouseleave=()=>dragging=false;
cv.onwheel=e=>{zoom*=e.deltaY>0?1.05:.95;zoom=Math.max(1.5,Math.min(8,zoom))};
cv.ontouchstart=e=>{dragging=true;lastMX=e.touches[0].clientX;lastMY=e.touches[0].clientY};
cv.ontouchmove=e=>{if(!dragging)return;rotX+=(e.touches[0].clientX-lastMX)*.004;rotY+=(e.touches[0].clientY-lastMY)*.004;rotY=Math.max(-1.5,Math.min(1.5,rotY));lastMX=e.touches[0].clientX;lastMY=e.touches[0].clientY};
cv.ontouchend=()=>dragging=false;

const qb=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,qb);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);

const VERT=`
attribute vec2 aPos;
varying vec2 vUV;
void main(){
  vUV=aPos;
  gl_Position=vec4(aPos,0.0,1.0);
}`;

// NOTE: all noise function parameters carefully named to avoid
// colliding with varying/uniform names.
const FRAG=`
precision highp float;
varying vec2 vUV;
uniform vec2 uRes;
uniform float uTime, uRotX, uRotY, uZoom, uPlanet;

//
// Simplex 3D noise - Ashima Arts
// All parameter names prefixed to avoid shadowing varyings/uniforms
//
vec3 mod289_3(vec3 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 mod289_4(vec4 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 permute(vec4 x){ return mod289_4(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }

float snoise(vec3 pos){
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

  vec3 ii = floor(pos + dot(pos, C.yyy));
  vec3 x0 = pos - ii + dot(ii, C.xxx);

  vec3 gg = step(x0.yzx, x0.xyz);
  vec3 ll = 1.0 - gg;
  vec3 i1 = min(gg.xyz, ll.zxy);
  vec3 i2 = max(gg.xyz, ll.zxy);

  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;

  ii = mod289_3(ii);
  vec4 pp = permute(permute(permute(
    ii.z + vec4(0.0, i1.z, i2.z, 1.0))
  + ii.y + vec4(0.0, i1.y, i2.y, 1.0))
  + ii.x + vec4(0.0, i1.x, i2.x, 1.0));

  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 jj = pp - 49.0 * floor(pp * ns.z * ns.z);

  vec4 x_ = floor(jj * ns.z);
  vec4 y_ = floor(jj - 7.0 * x_);

  vec4 xx = x_ * ns.x + ns.yyyy;
  vec4 yy = y_ * ns.x + ns.yyyy;
  vec4 hh = 1.0 - abs(xx) - abs(yy);

  vec4 b0 = vec4(xx.xy, yy.xy);
  vec4 b1 = vec4(xx.zw, yy.zw);

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 shh = -step(hh, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*shh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*shh.zzww;

  vec3 p0 = vec3(a0.xy, hh.x);
  vec3 p1 = vec3(a0.zw, hh.y);
  vec3 p2 = vec3(a1.xy, hh.z);
  vec3 p3 = vec3(a1.zw, hh.w);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;

  vec4 mm = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  mm = mm * mm;
  return 42.0 * dot(mm*mm, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

float fbm(vec3 p, float freq, int octaves){
  float sum = 0.0, amp = 0.5;
  for(int i=0; i<8; i++){
    if(i >= octaves) break;
    sum += snoise(p * freq) * amp;
    freq *= 2.0;
    amp *= 0.5;
  }
  return sum;
}

// ── Rotation matrices ──
mat3 rotY(float a){ float c=cos(a),s=sin(a); return mat3(c,0,s, 0,1,0, -s,0,c); }
mat3 rotX(float a){ float c=cos(a),s=sin(a); return mat3(1,0,0, 0,c,-s, 0,s,c); }

// ── Ray-sphere intersection ──
float raySphere(vec3 ro, vec3 rd, float r){
  float b = dot(ro,rd);
  float c = dot(ro,ro) - r*r;
  float d = b*b - c;
  if(d < 0.0) return -1.0;
  return -b - sqrt(d);
}

// ── ACES tonemapping ──
vec3 aces(vec3 x){
  return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14), 0.0, 1.0);
}

// ── Light direction ──
vec3 sunDir = normalize(vec3(1.0, 0.4, 0.6));

// ═══════════════════════════════════════
// PLANET SURFACE SHADERS
// ═══════════════════════════════════════

// 0: Terran
vec3 surfTerran(vec3 nn, float time){
  float cont = fbm(nn, 2.2, 5);
  float detail = fbm(nn + vec3(7.7), 5.0, 3) * 0.2;
  float landMask = smoothstep(-0.05, 0.12, cont + detail);
  float elev = smoothstep(0.1, 0.6, cont);
  float polar = smoothstep(0.7, 0.9, abs(nn.y) + cont * 0.08);

  // Ocean: deep navy to medium blue
  vec3 ocean = mix(vec3(0.01, 0.04, 0.18), vec3(0.03, 0.12, 0.30), smoothstep(-0.4, 0.0, cont));
  // Land: green coast → tan → grey mountains
  vec3 landCol = mix(vec3(0.12, 0.25, 0.06), vec3(0.22, 0.18, 0.08), smoothstep(0.2, 0.5, elev));
  landCol = mix(landCol, vec3(0.35, 0.30, 0.25), smoothstep(0.55, 0.8, elev));

  vec3 col = mix(ocean, landCol, landMask);
  col = mix(col, vec3(0.90, 0.93, 0.97), polar);

  // Clouds
  float clouds = fbm(nn + vec3(time*0.008, 0.0, time*0.005), 2.8, 4);
  clouds = smoothstep(0.05, 0.50, clouds);
  col = mix(col, vec3(0.95, 0.97, 1.0), clouds * 0.50);
  return col;
}

// 1: Desert — warm Mars/Arrakis tones
vec3 surfDesert(vec3 nn){
  float terrain = fbm(nn, 2.5, 5) * 0.5 + 0.5;
  float dunes = fbm(nn + vec3(8.0), 5.0, 3) * 0.5 + 0.5;
  float craterMask = smoothstep(0.65, 0.72, fbm(nn * 1.2, 1.5, 3) * 0.5 + 0.5);

  vec3 rust = vec3(0.52, 0.20, 0.08);
  vec3 ochre = vec3(0.65, 0.38, 0.15);
  vec3 sand = vec3(0.76, 0.58, 0.32);

  vec3 col = mix(rust, ochre, terrain);
  col = mix(col, sand, dunes * 0.4);
  col = mix(col, rust * 0.5, craterMask * 0.5);

  float frost = smoothstep(0.90, 0.97, abs(nn.y));
  col = mix(col, vec3(0.80, 0.72, 0.62), frost);
  return col;
}

// 2: Ice — Europa blue-white with cracks
vec3 surfIce(vec3 nn){
  float terrain = fbm(nn, 2.0, 4) * 0.5 + 0.5;

  // Crack network
  float crack1 = 1.0 - smoothstep(0.0, 0.06, abs(snoise(nn * 5.0)));
  float crack2 = 1.0 - smoothstep(0.0, 0.04, abs(snoise(nn * 3.5 + vec3(20.0))));
  float cracks = max(crack1 * 0.8, crack2 * 0.5);

  vec3 iceCol = mix(vec3(0.62, 0.72, 0.82), vec3(0.82, 0.87, 0.92), terrain);
  // Cracks are deep blue
  iceCol = mix(iceCol, vec3(0.10, 0.18, 0.35), cracks);
  // Mineral stain
  float stain = smoothstep(0.55, 0.70, fbm(nn * 1.2 + vec3(40.0), 1.8, 3) * 0.5 + 0.5);
  iceCol = mix(iceCol, vec3(0.72, 0.65, 0.55), stain * 0.10);
  return iceCol;
}

// 3: Gas Giant — deep blue hot Jupiter (HD 189733 b)
vec3 surfGas(vec3 nn, float time){
  float lat = nn.y;
  float turb = fbm(nn * 1.5 + vec3(time*0.002, 0.0, 0.0), 3.0, 4);
  float bands = sin(lat * 20.0 + turb * 2.5) * 0.5 + 0.5;
  float fine = sin(lat * 50.0 + turb * 4.0) * 0.5 + 0.5;
  bands = bands * 0.7 + fine * 0.3;

  vec3 darkBlue = vec3(0.04, 0.08, 0.22);
  vec3 midBlue = vec3(0.12, 0.22, 0.42);
  vec3 lightBlue = vec3(0.30, 0.45, 0.60);

  vec3 col = mix(darkBlue, midBlue, bands);
  col = mix(col, lightBlue, fine * 0.3);

  float eq = exp(-lat*lat*6.0);
  col = mix(col, vec3(0.20, 0.30, 0.45), eq * 0.2);

  float wisps = fbm(nn * 3.0 + vec3(lat*2.0 + time*0.003, 0.0, 0.0), 5.0, 3);
  col += vec3(0.05, 0.08, 0.12) * smoothstep(0.2, 0.6, wisps);
  return col;
}

// 4: Lava — obsidian crust with magma veins
vec3 surfLava(vec3 nn, float time){
  float plates = fbm(nn, 2.0, 4);

  float vein1 = abs(snoise(nn * 4.0 + vec3(time*0.005, 0.0, 0.0)));
  float vein2 = abs(snoise(nn * 7.0 + vec3(0.0, time*0.003, 5.0)));
  float veins = 1.0 - smoothstep(0.0, 0.10, min(vein1, vein2));

  float pools = smoothstep(-0.15, 0.10, -plates);
  float heat = clamp(veins * 0.65 + pools * 0.50, 0.0, 1.0);
  float pulse = 0.90 + 0.10 * sin(time * 0.2 + plates * 4.0);

  vec3 crustCol = mix(vec3(0.04, 0.03, 0.025), vec3(0.10, 0.07, 0.05), plates * 0.5 + 0.5);
  vec3 magmaCol = mix(vec3(0.70, 0.10, 0.0), vec3(1.0, 0.55, 0.05), heat);

  return mix(crustCol, magmaCol * pulse, heat);
}

// 5: Ocean — deep blue global ocean
vec3 surfOcean(vec3 nn, float time){
  float depth = fbm(nn, 1.8, 4);
  float curr = snoise(nn * 3.5 + vec3(time*0.006, 0.0, time*0.004)) * 0.15;

  vec3 deepBlue = vec3(0.005, 0.015, 0.10);
  vec3 midOcean = vec3(0.015, 0.06, 0.20);
  vec3 shallow = vec3(0.04, 0.14, 0.28);

  float dv = depth * 0.5 + 0.5 + curr;
  vec3 col = mix(deepBlue, midOcean, smoothstep(0.3, 0.55, dv));
  col = mix(col, shallow, smoothstep(0.6, 0.85, dv));

  // Tiny volcanic islands
  float isle = smoothstep(0.63, 0.66, depth);
  col = mix(col, vec3(0.14, 0.20, 0.07), isle * 0.5);

  // Thick clouds
  float cl = fbm(nn * 0.9 + vec3(time*0.007, time*0.004, 0.0), 2.5, 5);
  float cover = smoothstep(-0.10, 0.40, cl);
  float cyclone = snoise(vec3(atan(nn.z, nn.x)*1.5, nn.y*4.0, time*0.003));
  cover += smoothstep(0.35, 0.55, cyclone) * 0.15;
  cover = clamp(cover, 0.0, 1.0);
  col = mix(col, vec3(0.88, 0.92, 0.96), cover * 0.60);
  return col;
}

// 6: Ringed — Saturn-like warm cream/gold body
vec3 surfRinged(vec3 nn, float time){
  float lat = nn.y;
  float bands = sin(lat * 16.0 + fbm(nn * 1.2, 2.5, 3) * 1.5) * 0.5 + 0.5;
  float flow = fbm(nn + vec3(time*0.002, 0.0, 0.0), 3.0, 3);

  vec3 lightBand = vec3(0.85, 0.78, 0.55);
  vec3 darkBand = vec3(0.60, 0.48, 0.28);
  vec3 col = mix(darkBand, lightBand, bands);
  col = mix(col, vec3(0.75, 0.65, 0.40), flow * 0.15);

  float pole = smoothstep(0.6, 0.95, abs(lat));
  col = mix(col, vec3(0.40, 0.35, 0.22), pole * 0.30);
  return col;
}

// ═══════════════════════════════════════
// MAIN
// ═══════════════════════════════════════
void main(){
  vec2 uv = vUV;
  float aspect = uRes.x / uRes.y;
  uv.x *= aspect;

  // Camera
  vec3 camPos = rotY(uRotX) * rotX(uRotY) * vec3(0.0, 0.0, uZoom);
  vec3 fwd = normalize(-camPos);
  vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, fwd);
  vec3 rd = normalize(fwd + uv.x * right + uv.y * up);

  vec3 col = vec3(0.0);
  float time = uTime;
  int pl = int(uPlanet + 0.5);

  float hit = raySphere(camPos, rd, 1.0);

  // ── Ring setup (planet 6 only) ──
  float tiltAngle = 0.45; // ~26 degrees
  mat3 tiltMat = rotX(tiltAngle);
  float ringAlpha = 0.0;
  float ringDist = -1.0;
  vec3 ringColor = vec3(0.0);

  if(pl == 6){
    vec3 ro2 = tiltMat * camPos;
    vec3 rd2 = tiltMat * rd;
    if(abs(rd2.y) > 0.0001){
      float rt = -ro2.y / rd2.y;
      if(rt > 0.0){
        vec3 rp = ro2 + rd2 * rt;
        float rr = length(rp.xz);
        if(rr > 1.25 && rr < 2.70){
          ringDist = rt;
          float u = (rr - 1.25) / 1.45; // 0→1 across ring

          // Band pattern
          float b1 = sin(u * 45.0) * 0.5 + 0.5;
          float b2 = sin(u * 120.0) * 0.5 + 0.5;

          // Cassini-style gaps
          float gap1 = smoothstep(0.0, 0.04, abs(u - 0.35));
          float gap2 = smoothstep(0.0, 0.02, abs(u - 0.62));
          float gaps = gap1 * gap2;

          // Saturn-like ring colors
          vec3 innerRing = vec3(0.65, 0.55, 0.38);
          vec3 outerRing = vec3(0.82, 0.76, 0.60);
          ringColor = mix(innerRing, outerRing, u);
          ringColor = mix(ringColor, ringColor * 1.1, b1 * 0.2);
          ringColor = mix(ringColor, ringColor * 0.8, b2 * 0.1);

          // Ring lighting
          float rl = abs(dot(tiltMat * sunDir, vec3(0.0, 1.0, 0.0)));
          ringColor *= (0.35 + 0.65 * rl);

          ringAlpha = (0.35 + b1 * 0.35) * gaps;

          // Planet shadow on ring
          if(length(rp.xz) < 1.05) ringAlpha *= 0.15;
        }
      }
    }
  }

  // ── Planet surface rendering ──
  if(hit > 0.0 && (ringDist < 0.0 || hit < ringDist)){
    vec3 hitPos = camPos + rd * hit;
    vec3 normal = normalize(hitPos);
    vec3 surfNorm = (pl == 6) ? tiltMat * normal : normal;

    // Get surface color
    vec3 surface = vec3(0.5);
    bool emissive = false;

    if(pl == 0) surface = surfTerran(surfNorm, time);
    else if(pl == 1) surface = surfDesert(surfNorm);
    else if(pl == 2) surface = surfIce(surfNorm);
    else if(pl == 3) surface = surfGas(surfNorm, time);
    else if(pl == 4){ surface = surfLava(surfNorm, time); emissive = true; }
    else if(pl == 5) surface = surfOcean(surfNorm, time);
    else if(pl == 6) surface = surfRinged(surfNorm, time);

    // Lighting
    float NdotL = dot(normal, sunDir);
    float lit = smoothstep(-0.08, 0.20, NdotL); // soft terminator
    float ambient = 0.03;

    if(emissive){
      float glow = length(surface) / 1.73;
      col = surface * (ambient + lit * 0.35) + surface * glow * 1.1;
    } else {
      col = surface * (ambient + lit * 0.95);

      // Specular for watery/icy planets
      if(pl == 0 || pl == 2 || pl == 5){
        vec3 viewDir = normalize(camPos - hitPos);
        vec3 halfDir = normalize(sunDir + viewDir);
        float spec = pow(max(dot(normal, halfDir), 0.0), 50.0);
        col += vec3(0.9) * spec * 0.20 * lit;
      }
    }

    // Atmosphere rim glow
    float NdotV = max(dot(normal, normalize(camPos - hitPos)), 0.0);
    float rim = pow(1.0 - NdotV, 3.5);
    vec3 atmosCol = vec3(0.3, 0.5, 0.9);
    float atmosStr = 0.30;

    if(pl == 0){ atmosCol = vec3(0.35, 0.55, 1.0); atmosStr = 0.35; }
    else if(pl == 1){ atmosCol = vec3(0.60, 0.35, 0.15); atmosStr = 0.12; }
    else if(pl == 2){ atmosCol = vec3(0.40, 0.55, 0.75); atmosStr = 0.08; }
    else if(pl == 3){ atmosCol = vec3(0.15, 0.25, 0.50); atmosStr = 0.25; }
    else if(pl == 4){ atmosCol = vec3(0.70, 0.20, 0.05); atmosStr = 0.25; }
    else if(pl == 5){ atmosCol = vec3(0.20, 0.40, 0.85); atmosStr = 0.40; }
    else if(pl == 6){ atmosCol = vec3(0.55, 0.50, 0.30); atmosStr = 0.15; }

    col += atmosCol * rim * atmosStr * (0.3 + lit * 0.7);

    // Ring shadow on planet surface
    if(pl == 6){
      vec3 nt = tiltMat * normal;
      vec3 lt = tiltMat * sunDir;
      if(abs(lt.y) > 0.001){
        float ts = -nt.y / lt.y;
        if(ts > 0.0){
          float sr = length((nt + lt * ts).xz);
          if(sr > 1.25 && sr < 2.70){
            float su = (sr - 1.25) / 1.45;
            float sg = smoothstep(0.0, 0.04, abs(su - 0.35)) * smoothstep(0.0, 0.02, abs(su - 0.62));
            col *= mix(1.0, 0.45, sg);
          }
        }
      }
    }
  }

  // Ring in front of planet
  if(pl == 6 && ringDist > 0.0 && (hit < 0.0 || ringDist < hit)){
    col = mix(col, ringColor, ringAlpha);
  }

  // Atmosphere glow (when not hitting surface)
  if(hit < 0.0){
    float bDot = dot(camPos, rd);
    float closestDist = length(camPos + rd * max(-bDot, 0.0));
    float edgeDist = max(0.0, closestDist - 1.0);
    vec3 glowCol = vec3(0.3, 0.5, 0.9);
    if(pl == 1) glowCol = vec3(0.55, 0.30, 0.12);
    else if(pl == 3) glowCol = vec3(0.12, 0.20, 0.40);
    else if(pl == 4) glowCol = vec3(0.60, 0.15, 0.03);
    else if(pl == 6) glowCol = vec3(0.50, 0.45, 0.25);
    col += glowCol * exp(-edgeDist * 10.0) * 0.10;
  }

  // Background stars
  if(hit < 0.0){
    vec3 dir = normalize(rd);
    float theta = acos(clamp(dir.y, -1.0, 1.0));
    float phi = atan(dir.z, dir.x);
    for(int layer = 0; layer < 2; layer++){
      float fl = float(layer);
      float density = 140.0 + fl * 90.0;
      vec2 grid = vec2(phi * density, theta * density);
      vec2 cellId = floor(grid);
      vec2 cellFrac = fract(grid) - 0.5;
      float hash = fract(sin(dot(cellId + fl*50.0, vec2(127.1, 311.7))) * 43758.5453);
      if(hash > 0.97){
        vec2 starOff = vec2(
          fract(sin(dot(cellId+fl*50.0, vec2(269.5,183.3)))*43758.5453),
          fract(sin(dot(cellId+fl*50.0, vec2(419.2,371.9)))*43758.5453)
        ) - 0.5;
        float starDist = length(cellFrac - starOff * 0.5);
        float brightness = (hash - 0.97) / 0.03;
        float twinkle = 0.7 + 0.3 * sin(time*(1.0+hash*3.0) + hash*99.0);
        vec3 starCol = mix(vec3(0.6,0.7,1.0), vec3(1.0,0.9,0.7), fract(hash*7.0));
        col += starCol * exp(-starDist*starDist*1200.0) * brightness * twinkle * (1.0-fl*0.35) * 0.30;
      }
    }
  }

  // Tonemapping and post
  col = aces(col * 1.3);
  col *= 1.0 - 0.20 * dot(vUV * 0.5, vUV * 0.5); // vignette
  col = pow(col, vec3(0.96)); // slight gamma
  gl_FragColor = vec4(col, 1.0);
}
`;

function makeShader(type, source){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, source);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    console.error('Shader error:', gl.getShaderInfoLog(sh));
    return null;
  }
  return sh;
}
function makeProgram(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error('Link error:', gl.getProgramInfoLog(p));
    return null;
  }
  return p;
}

const vShader = makeShader(gl.VERTEX_SHADER, VERT);
const fShader = makeShader(gl.FRAGMENT_SHADER, FRAG);
const prog = makeProgram(vShader, fShader);

const aPos = gl.getAttribLocation(prog, 'aPos');
const uRes = gl.getUniformLocation(prog, 'uRes');
const uTime = gl.getUniformLocation(prog, 'uTime');
const uRotXLoc = gl.getUniformLocation(prog, 'uRotX');
const uRotYLoc = gl.getUniformLocation(prog, 'uRotY');
const uZoomLoc = gl.getUniformLocation(prog, 'uZoom');
const uPlanetLoc = gl.getUniformLocation(prog, 'uPlanet');

gl.useProgram(prog);
gl.enableVertexAttribArray(aPos);
gl.bindBuffer(gl.ARRAY_BUFFER, qb);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const startTime = performance.now();
(function loop(){
  const t = (performance.now() - startTime) / 1000.0;
  currentIdx += (targetIdx - currentIdx) * 0.06;
  if(!dragging) rotX += 0.0006;

  gl.uniform2f(uRes, cv.width, cv.height);
  gl.uniform1f(uTime, t);
  gl.uniform1f(uRotXLoc, rotX);
  gl.uniform1f(uRotYLoc, rotY);
  gl.uniform1f(uZoomLoc, zoom);
  gl.uniform1f(uPlanetLoc, currentIdx);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
