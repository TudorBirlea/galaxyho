<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>★ Procedural Star</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; }
  canvas { display: block; width: 100%; height: 100%; }

  #controls {
    position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 8px; z-index: 10; flex-wrap: wrap; justify-content: center;
  }
  .star-btn {
    padding: 6px 14px; border: 1px solid rgba(255,255,255,0.15);
    background: rgba(0,0,0,0.6); color: rgba(255,255,255,0.7);
    font-family: inherit; font-size: 11px; letter-spacing: 1px;
    cursor: pointer; border-radius: 4px; transition: all 0.3s;
    text-transform: uppercase; backdrop-filter: blur(8px);
  }
  .star-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
  .star-btn.active { border-color: rgba(255,200,100,0.6); color: #ffd080; background: rgba(255,200,100,0.08); }

  #info-panel {
    position: fixed; top: 24px; left: 24px; z-index: 10;
    color: rgba(255,255,255,0.5); font-size: 11px; letter-spacing: 1px;
    line-height: 1.8;
  }
  #info-panel .label { color: rgba(255,255,255,0.3); }
  #info-panel .value { color: rgba(255,200,150,0.8); }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="info-panel">
  <div><span class="label">STAR </span><span class="value" id="star-name">The Sun (Sol)</span></div>
  <div><span class="label">TEMP </span><span class="value" id="star-temp">5,778 K</span></div>
  <div><span class="label">CLASS </span><span class="value" id="star-class">G2V</span></div>
</div>

<div id="controls">
  <button class="star-btn active" data-star="sun">Sol · G2V</button>
  <button class="star-btn" data-star="red">Betelgeuse · M1</button>
  <button class="star-btn" data-star="orange">Arcturus · K1.5</button>
  <button class="star-btn" data-star="white">Sirius · A1V</button>
  <button class="star-btn" data-star="blue">Rigel · B8Ia</button>
  <button class="star-btn" data-star="cool">Proxima · M5.5</button>
</div>

<script>
// ─── Star definitions ───────────────────────────────────────
const STARS = {
  sun:    { name: 'The Sun (Sol)',     temp: 5778,  cls: 'G2V',   spots: 1.0, granuleScale: 1.0 },
  red:    { name: 'Betelgeuse',        temp: 3500,  cls: 'M1Iab', spots: 0.3, granuleScale: 0.6 },
  orange: { name: 'Arcturus',          temp: 4286,  cls: 'K1.5III', spots: 0.5, granuleScale: 0.8 },
  white:  { name: 'Sirius A',         temp: 9940,  cls: 'A1V',   spots: 0.1, granuleScale: 1.4 },
  blue:   { name: 'Rigel',            temp: 12100, cls: 'B8Ia',  spots: 0.05, granuleScale: 1.6 },
  cool:   { name: 'Proxima Centauri', temp: 3042,  cls: 'M5.5Ve', spots: 1.5, granuleScale: 0.5 },
};

let currentStar = STARS.sun;
let targetTemp = currentStar.temp;
let currentTemp = currentStar.temp;
let targetSpots = currentStar.spots;
let currentSpots = currentStar.spots;
let targetGranule = currentStar.granuleScale;
let currentGranule = currentStar.granuleScale;

// ─── UI ─────────────────────────────────────────────────────
document.querySelectorAll('.star-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.star-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const s = STARS[btn.dataset.star];
    currentStar = s;
    targetTemp = s.temp;
    targetSpots = s.spots;
    targetGranule = s.granuleScale;
    document.getElementById('star-name').textContent = s.name;
    document.getElementById('star-temp').textContent = s.temp.toLocaleString() + ' K';
    document.getElementById('star-class').textContent = s.cls;
  });
});

// ─── WebGL setup ────────────────────────────────────────────
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, alpha: false });

function resize() {
  const dpr = Math.min(window.devicePixelRatio, 2);
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// ─── Mouse ──────────────────────────────────────────────────
let rotX = 0.0, rotY = 0.0, zoomDist = 3.0;
let dragging = false, lastMX = 0, lastMY = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  rotX += (e.clientX - lastMX) * 0.005;
  rotY += (e.clientY - lastMY) * 0.005;
  rotY = Math.max(-1.5, Math.min(1.5, rotY));
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
  zoomDist *= e.deltaY > 0 ? 1.06 : 0.94;
  zoomDist = Math.max(1.3, Math.min(12.0, zoomDist));
}, { passive: true });

canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!dragging) return;
  rotX += (e.touches[0].clientX - lastMX) * 0.005;
  rotY += (e.touches[0].clientY - lastMY) * 0.005;
  rotY = Math.max(-1.5, Math.min(1.5, rotY));
  lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', () => dragging = false);

// ─── Shader helpers ─────────────────────────────────────────
function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(s));
    gl.deleteShader(s); return null;
  }
  return s;
}
function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(p)); return null;
  }
  return p;
}

// ─── Quad ───────────────────────────────────────────────────
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

// ─── Vertex shader ──────────────────────────────────────────
const vertSrc = `
attribute vec2 aPos;
varying vec2 vUV;
void main() {
  vUV = aPos;
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

// ─── Fragment shader ────────────────────────────────────────
// Implements the full bpodgursky / Seeds of Andromeda approach:
// - Ray-sphere intersection for a unit sphere
// - 3D simplex noise on the sphere surface (4 octaves for granules)
// - Sunspot layer: low-freq noise, max(0,...) for discrete spots
// - Bright spot layer: medium-freq noise for hotter regions
// - Per-pixel temperature → black-body RGB color
// - Animated: noise coordinates shift with time
// - Corona / glow layer around the sphere
// - Limb darkening for realism
// - ACES tonemapping
const fragSrc = `
precision highp float;
varying vec2 vUV;

uniform vec2 uResolution;
uniform float uTime;
uniform float uRotX;
uniform float uRotY;
uniform float uZoom;       // camera distance
uniform float uHighTemp;   // star surface high temperature
uniform float uSpotAmount; // sunspot intensity multiplier
uniform float uGranuleScale; // granule noise frequency multiplier

// ─── ACES Tonemapping ────────────────────────────────
vec3 ACESFilm(vec3 x) {
  float a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14;
  return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
}

// ─── 3D Simplex noise (Ashima) ───────────────────────
vec3 mod289v3(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 mod289v4(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289v4(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289v3(i);
  vec4 p = permute(permute(permute(
    i.z + vec4(0.0, i1.z, i2.z, 1.0))
  + i.y + vec4(0.0, i1.y, i2.y, 1.0))
  + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}

// ─── FBM noise (multi-octave) ────────────────────────
float fbm(vec3 p, float freq, float lacunarity, float gain, int octaves) {
  float sum = 0.0;
  float amp = 1.0;
  float f = freq;
  for (int i = 0; i < 8; i++) {
    if (i >= octaves) break;
    sum += snoise(p * f) * amp;
    f *= lacunarity;
    amp *= gain;
  }
  return sum;
}

// ─── Black-body radiation → RGB ──────────────────────
// Attempt to follow the blackbody color spectrum
// Attempt to match the SoA star_spectrum_3 texture
vec3 tempToColor(float tempK) {
  // Attempt the polynomial fit approach (Tanner Helland's method)
  float t = clamp(tempK, 1000.0, 40000.0) / 100.0;
  float r, g, b;

  // Red
  if (t <= 66.0) {
    r = 255.0;
  } else {
    r = 329.698727446 * pow(t - 60.0, -0.1332047592);
  }

  // Green
  if (t <= 66.0) {
    g = 99.4708025861 * log(t) - 161.1195681661;
  } else {
    g = 288.1221695283 * pow(t - 60.0, -0.0755148492);
  }

  // Blue
  if (t >= 66.0) {
    b = 255.0;
  } else if (t <= 19.0) {
    b = 0.0;
  } else {
    b = 138.5177312231 * log(t - 10.0) - 305.0447927307;
  }

  return clamp(vec3(r, g, b) / 255.0, 0.0, 1.0);
}

// ─── Rotation matrices ───────────────────────────────
mat3 rotY(float a) {
  float c = cos(a), s = sin(a);
  return mat3(c,0,s, 0,1,0, -s,0,c);
}
mat3 rotX(float a) {
  float c = cos(a), s = sin(a);
  return mat3(1,0,0, 0,c,-s, 0,s,c);
}

// ─── Ray-sphere intersection ─────────────────────────
// Returns distance to hit, or -1.0 if miss
float raySphere(vec3 ro, vec3 rd, float radius) {
  float b = dot(ro, rd);
  float c = dot(ro, ro) - radius * radius;
  float disc = b*b - c;
  if (disc < 0.0) return -1.0;
  return -b - sqrt(disc);
}

void main() {
  vec2 uv = vUV;
  float aspect = uResolution.x / uResolution.y;
  uv.x *= aspect;

  // ── Camera setup ──
  vec3 camPos = vec3(0.0, 0.0, uZoom);
  camPos = rotY(uRotX) * rotX(uRotY) * camPos;
  vec3 target = vec3(0.0);
  vec3 fwd = normalize(target - camPos);
  vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, fwd);
  vec3 rd = normalize(fwd + uv.x * right + uv.y * up);

  vec3 col = vec3(0.0);

  // ── Star surface ──
  float hit = raySphere(camPos, rd, 1.0);

  // Slow time for surface animation
  float slowTime = uTime * 0.04;

  if (hit > 0.0) {
    vec3 hitPos = camPos + rd * hit;
    vec3 normal = normalize(hitPos);

    // 3D surface coordinate for noise sampling
    // Slowly rotate the noise field to animate convection
    vec3 surfCoord = rotY(slowTime * 0.3) * normal;
    float gScale = 5.0 * uGranuleScale;

    // ── Layer 1: Base granule noise (4 octaves FBM) ──
    // Following bpodgursky: base noise = (noise(coord, freq, gain) + 1) / 2
    float granuleNoise = (fbm(surfCoord, gScale, 2.0, 0.5, 4) + 1.0) * 0.5;

    // ── Layer 2: Sunspots ──
    // Following bpodgursky: low freq, high amplitude, offset, max(0,...)
    // "float t1 = snoise(vTexCoord3D * frequency)*2.7 - 1.9; float ss = max(0.0, t1);"
    float spotFreq = gScale * 0.15;
    float spotNoise = snoise(surfCoord * spotFreq + vec3(slowTime * 0.1, 0.0, slowTime * 0.05));
    float sunspots = max(0.0, spotNoise * 2.7 - 1.9) * uSpotAmount;

    // ── Layer 3: Bright regions ──
    // "float brightNoise = snoise(vTexCoord3D * .02)*1.4 - .9; float brightSpot = max(0.0, brightNoise);"
    float brightFreq = gScale * 0.08;
    float brightNoise = snoise(surfCoord * brightFreq + vec3(0.0, slowTime * 0.15, 0.0));
    float brightSpot = max(0.0, brightNoise * 1.4 - 0.9);

    // ── Combine into temperature variation ──
    // Following bpodgursky: "total = noiseBase - ss + brightSpot"
    // Then map total (0-1 ish) between lowTemp and highTemp
    float total = granuleNoise - sunspots + brightSpot;
    total = clamp(total, 0.0, 1.5);

    float highTemp = uHighTemp;
    float lowTemp = uHighTemp * 0.25; // bpodgursky: lowTemp = highTemp / 4
    float pixelTemp = mix(lowTemp, highTemp, total);

    // Per-pixel color from temperature
    vec3 starCol = tempToColor(pixelTemp);

    // ── Limb darkening ──
    // The edge of the star should be darker (realistic effect)
    float NdotV = max(dot(normal, normalize(camPos - hitPos)), 0.0);
    float limb = pow(NdotV, 0.4); // gentle darkening at edges
    // Also slightly shift edge color warmer (cooler temp at limb)
    float limbTemp = mix(lowTemp * 1.5, pixelTemp, pow(NdotV, 0.6));
    vec3 limbCol = tempToColor(limbTemp);
    starCol = mix(limbCol, starCol, pow(NdotV, 0.3));
    starCol *= limb;

    // Brightness boost — hotter stars should be brighter overall
    float brightnessBoost = 1.0 + clamp((uHighTemp - 4000.0) / 15000.0, 0.0, 1.0) * 0.8;
    starCol *= brightnessBoost;

    col = starCol;
  }

  // ── Compute corona glow intensity (needed before stars) ──
  float b_corona = dot(camPos, rd);
  float closestDist = length(camPos + rd * max(-b_corona, 0.0));
  float edgeDist = max(0.0, closestDist - 1.0);

  // Tighter falloffs so the glow doesn't wash the whole screen gray
  float glow1 = exp(-edgeDist * 6.0) * 0.45;    // tight inner glow
  float glow2 = exp(-edgeDist * 2.5) * 0.08;     // medium halo
  float glow3 = exp(-edgeDist * 0.8) * 0.015;    // wide but very subtle
  float coronaBoost = 1.0 + clamp((uHighTemp - 4000.0) / 20000.0, 0.0, 0.4);
  float totalGlow = (glow1 + glow2 + glow3) * coronaBoost;

  // ── Background stars (only where we missed the star sphere) ──
  // Rendered BEFORE corona so the glow properly washes them out.
  if (hit < 0.0) {
    // Use ray direction in spherical coords for stable sky-sphere tiling
    vec3 d = normalize(rd);
    float theta = acos(clamp(d.y, -1.0, 1.0));
    float phi = atan(d.z, d.x);

    // Fade background stars where corona glow is strong
    float glowMask = 1.0 - clamp(totalGlow * 4.0, 0.0, 1.0);

    for (int layer = 0; layer < 3; layer++) {
      float fl = float(layer);
      float density = 120.0 + fl * 80.0;
      vec2 grid = vec2(phi * density, theta * density);
      vec2 cellId = floor(grid);
      vec2 cellUV = fract(grid) - 0.5;

      float h = fract(sin(dot(cellId + fl * 50.0, vec2(127.1, 311.7))) * 43758.5453);
      float threshold = 0.96 + fl * 0.015;
      if (h > threshold) {
        vec2 starOff = vec2(
          fract(sin(dot(cellId + fl * 50.0, vec2(269.5, 183.3))) * 43758.5453),
          fract(sin(dot(cellId + fl * 50.0, vec2(419.2, 371.9))) * 43758.5453)
        ) - 0.5;
        float dist = length(cellUV - starOff * 0.6);

        float brightness = (h - threshold) / (1.0 - threshold);
        float twinkle = 0.7 + 0.3 * sin(uTime * (1.0 + h * 3.0) + h * 100.0);
        float point = exp(-dist * dist * 800.0) * brightness * twinkle;

        vec3 sCol = mix(vec3(0.6, 0.7, 1.0), vec3(1.0, 0.85, 0.7), fract(h * 7.0));
        float dimmer = 1.0 - fl * 0.3;
        col += sCol * point * dimmer * 0.5 * glowMask;
      }
    }
  }

  // ── Corona / Glow (rendered on top) ──
  {
    vec3 glowColor = tempToColor(uHighTemp);
    float whiteness = exp(-edgeDist * 3.0);
    glowColor = mix(glowColor, vec3(1.0), whiteness * 0.5);
    col += glowColor * totalGlow;
  }

  // ── Tonemap ──
  col = ACESFilm(col * 1.5);

  // ── Subtle vignette ──
  float vig = 1.0 - 0.3 * dot(vUV * 0.5, vUV * 0.5);
  col *= vig;

  // ── Final gamma ──
  col = pow(col, vec3(0.95));

  gl_FragColor = vec4(col, 1.0);
}
`;

// ─── Build ──────────────────────────────────────────────────
const vs = createShader(gl.VERTEX_SHADER, vertSrc);
const fs = createShader(gl.FRAGMENT_SHADER, fragSrc);
const prog = createProgram(vs, fs);

const aPos = gl.getAttribLocation(prog, 'aPos');
const uRes = gl.getUniformLocation(prog, 'uResolution');
const uTime = gl.getUniformLocation(prog, 'uTime');
const uRotXU = gl.getUniformLocation(prog, 'uRotX');
const uRotYU = gl.getUniformLocation(prog, 'uRotY');
const uZoomU = gl.getUniformLocation(prog, 'uZoom');
const uHighTempU = gl.getUniformLocation(prog, 'uHighTemp');
const uSpotU = gl.getUniformLocation(prog, 'uSpotAmount');
const uGranU = gl.getUniformLocation(prog, 'uGranuleScale');

gl.useProgram(prog);
gl.enableVertexAttribArray(aPos);
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// ─── Render ─────────────────────────────────────────────────
const t0 = performance.now();

function render() {
  const t = (performance.now() - t0) / 1000.0;

  // Smooth transitions between star types
  currentTemp += (targetTemp - currentTemp) * 0.03;
  currentSpots += (targetSpots - currentSpots) * 0.03;
  currentGranule += (targetGranule - currentGranule) * 0.03;

  // Gentle auto-rotation
  if (!dragging) {
    rotX += 0.001;
  }

  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform1f(uTime, t);
  gl.uniform1f(uRotXU, rotX);
  gl.uniform1f(uRotYU, rotY);
  gl.uniform1f(uZoomU, zoomDist);
  gl.uniform1f(uHighTempU, currentTemp);
  gl.uniform1f(uSpotU, currentSpots);
  gl.uniform1f(uGranU, currentGranule);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
