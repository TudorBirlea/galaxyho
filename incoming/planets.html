<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Exoplanets</title>
<style>
/* ═══════════════════════════════════════════════════════════════
   STYLES
   - Full-screen black canvas with monospace UI overlay
   - Bottom button bar for planet selection
   - Top-left HUD showing current planet info
   ═══════════════════════════════════════════════════════════════ */
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #000;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
}
canvas { display: block; width: 100%; height: 100%; }

/* ── Bottom control bar ── */
#ctrl {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  z-index: 10;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 95vw;
}
.pb {
  padding: 5px 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.7);
  color: rgba(255,255,255,.55);
  font-family: inherit;
  font-size: 10px;
  letter-spacing: .8px;
  cursor: pointer;
  border-radius: 3px;
  transition: all .3s;
  text-transform: uppercase;
  backdrop-filter: blur(6px);
  white-space: nowrap;
}
.pb:hover { background: rgba(255,255,255,.08); color: #fff; }
.pb.on {
  border-color: rgba(100,180,255,.5);
  color: #8cf;
  background: rgba(100,180,255,.06);
}

/* ── Top-left info HUD ── */
#hud {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10;
  color: rgba(255,255,255,.45);
  font-size: 10px;
  letter-spacing: 1px;
  line-height: 2;
}
.hl { color: rgba(255,255,255,.25); }
.hv { color: rgba(130,200,255,.8); }
.hf { color: rgba(255,255,255,.3); font-style: italic; letter-spacing: .5px; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- ═══════════════════════════════════════════════════════════════
     HUD — displays current planet name, type, and flavor text.
     Updated by JavaScript when switching planets.
     ═══════════════════════════════════════════════════════════════ -->
<div id="hud">
  <div><span class="hl">PLANET </span><span class="hv" id="pn"></span></div>
  <div><span class="hl">TYPE </span><span class="hv" id="pt"></span></div>
  <div><span class="hf" id="pf"></span></div>
</div>

<!-- Button bar — populated dynamically from PLANETS array -->
<div id="ctrl"></div>

<script>
// ═══════════════════════════════════════════════════════════════
// PLANET CONFIGURATION
// ═══════════════════════════════════════════════════════════════
//
// Each planet entry defines:
//   name     — display name (shown in HUD)
//   type     — short category label (shown on button + HUD)
//   flavor   — italic description line
//   texture  — path to equirectangular texture image (relative to this HTML file)
//              Textures should be 2:1 aspect ratio JPGs (e.g. 1024x512, 2048x1024)
//              Stored in a "textures/" subfolder next to this HTML file
//   shader   — which shader style to use for this planet:
//              "terrestrial" — directional light + specular + blue atmosphere
//              "ocean"       — full-surface specular + blue-green atmosphere
//              "lava"        — emissive glow on bright areas + red atmosphere
//              "gas"         — soft lighting + no specular + thin atmosphere
//              "ice"         — subtle specular + pale blue atmosphere
//   atmos    — atmosphere color [r, g, b] (0-1 range)
//   atmosStr — atmosphere intensity (0 = none, 0.3 = normal, 0.5 = thick)
//   spinRate — rotation speed multiplier (1.0 = default, 0.5 = slow, 2.0 = fast)
//
// TO ADD A NEW PLANET:
//   1. Place your equirectangular texture JPG in the textures/ folder
//   2. Add a new entry to this array
//   3. Choose the shader type that best matches the planet's character
//
const PLANETS = [
  {
    name: 'Kepler-22 b',
    type: 'Ocean',
    flavor: 'Deep global ocean · thick atmosphere',
    texture: 'textures/kepler_22b.jpg',
    shader: 'ocean',
    atmos: [0.15, 0.45, 0.35],
    atmosStr: 0.30,
    spinRate: 1.0,
  },
  {
    name: '55 Cancri e',
    type: 'Lava',
    flavor: 'Molten surface · extreme metals',
    texture: 'textures/55_cancri_e.jpg',
    shader: 'lava',
    atmos: [0.70, 0.18, 0.04],
    atmosStr: 0.25,
    spinRate: 0.8,
  },
  {
    name: 'TRAPPIST-1 e',
    type: 'Terran',
    flavor: 'Earth-like · high habitability',
    texture: 'textures/trappist_1e.jpg',
    shader: 'terrestrial',
    atmos: [0.30, 0.50, 1.00],
    atmosStr: 0.30,
    spinRate: 1.0,
  },
  {
    name: 'HD 189733 b',
    type: 'Gas Giant',
    flavor: 'Hot Jupiter · silicate rain',
    texture: 'textures/hd_189733b.jpg',
    shader: 'gas',
    atmos: [0.12, 0.20, 0.45],
    atmosStr: 0.20,
    spinRate: 1.5,
  },
  {
    name: 'Kepler-442 b',
    type: 'Desert',
    flavor: 'Arid super-Earth · high metals',
    texture: 'textures/kepler_442b.jpg',
    shader: 'terrestrial',
    atmos: [0.55, 0.30, 0.12],
    atmosStr: 0.12,
    spinRate: 0.9,
  },
  {
    name: 'GJ 1214 b',
    type: 'Water',
    flavor: 'Sub-Neptune · deep ocean · thick clouds',
    texture: 'textures/gj_1214b.jpg',
    shader: 'ocean',
    atmos: [0.20, 0.40, 0.85],
    atmosStr: 0.35,
    spinRate: 1.2,
  },
  {
    name: 'OGLE-2005-BLG-390L b',
    type: 'Ice',
    flavor: 'Frozen world · rare elements',
    texture: 'textures/ogle_2005.jpg',
    shader: 'ice',
    atmos: [0.40, 0.55, 0.70],
    atmosStr: 0.10,
    spinRate: 0.7,
  },
];

// ═══════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════

let currentPlanetIdx = 0;   // Index into PLANETS array
let targetPlanetIdx = 0;    // For smooth transitions (not yet used, reserved)

// Camera orbit state (modified by mouse/touch drag)
let rotX = 0.4;             // Horizontal orbit angle (radians)
let rotY = 0.15;            // Vertical orbit angle (radians), clamped to ±1.5
let zoom = 3.0;             // Camera distance from origin
let dragging = false;
let lastMX = 0, lastMY = 0;

// ═══════════════════════════════════════════════════════════════
// UI SETUP — build buttons and HUD from PLANETS array
// ═══════════════════════════════════════════════════════════════

const ctrl = document.getElementById('ctrl');

PLANETS.forEach((p, i) => {
  const btn = document.createElement('button');
  btn.className = 'pb' + (i === 0 ? ' on' : '');
  btn.textContent = p.type;
  btn.onclick = () => {
    // Update button highlight
    document.querySelectorAll('.pb').forEach(x => x.classList.remove('on'));
    btn.classList.add('on');

    // Switch planet
    currentPlanetIdx = i;

    // Update HUD text
    document.getElementById('pn').textContent = p.name;
    document.getElementById('pt').textContent = p.type;
    document.getElementById('pf').textContent = p.flavor;

    // Load the new texture
    loadTexture(p.texture);
  };
  ctrl.appendChild(btn);
});

// Initialize HUD with first planet
document.getElementById('pn').textContent = PLANETS[0].name;
document.getElementById('pt').textContent = PLANETS[0].type;
document.getElementById('pf').textContent = PLANETS[0].flavor;

// ═══════════════════════════════════════════════════════════════
// WEBGL SETUP
// ═══════════════════════════════════════════════════════════════

const cv = document.getElementById('c');
const gl = cv.getContext('webgl', { antialias: false, alpha: false });

// ── Resize handler — match canvas pixels to screen size ──
function resize() {
  const dpr = Math.min(devicePixelRatio, 2); // Cap at 2x to avoid GPU strain
  cv.width = innerWidth * dpr;
  cv.height = innerHeight * dpr;
  gl.viewport(0, 0, cv.width, cv.height);
}
addEventListener('resize', resize);
resize();

// ── Mouse controls — drag to orbit, scroll to zoom ──
cv.onmousedown = e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; };
cv.onmousemove = e => {
  if (!dragging) return;
  rotX += (e.clientX - lastMX) * 0.004;
  rotY += (e.clientY - lastMY) * 0.004;
  rotY = Math.max(-1.5, Math.min(1.5, rotY)); // Clamp vertical
  lastMX = e.clientX;
  lastMY = e.clientY;
};
cv.onmouseup = cv.onmouseleave = () => dragging = false;
cv.onwheel = e => {
  zoom *= e.deltaY > 0 ? 1.05 : 0.95;
  zoom = Math.max(1.5, Math.min(8, zoom));
};

// ── Touch controls — same as mouse but for mobile ──
cv.ontouchstart = e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; };
cv.ontouchmove = e => {
  if (!dragging) return;
  rotX += (e.touches[0].clientX - lastMX) * 0.004;
  rotY += (e.touches[0].clientY - lastMY) * 0.004;
  rotY = Math.max(-1.5, Math.min(1.5, rotY));
  lastMX = e.touches[0].clientX;
  lastMY = e.touches[0].clientY;
};
cv.ontouchend = () => dragging = false;

// ═══════════════════════════════════════════════════════════════
// TEXTURE MANAGEMENT
// ═══════════════════════════════════════════════════════════════

// Create a single GL texture object — we reuse it for all planets
const tex = gl.createTexture();
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, tex);

// Initialize with a 1x1 dark pixel (shown while texture loads)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
  new Uint8Array([10, 10, 15, 255]));

// Cache loaded images so switching back is instant
const textureCache = {};

function loadTexture(path) {
  // Check cache first
  if (textureCache[path]) {
    uploadTexture(textureCache[path]);
    return;
  }

  const img = new Image();
  img.onload = () => {
    textureCache[path] = img;
    uploadTexture(img);
    console.log(`Loaded: ${path} (${img.width}×${img.height})`);
  };
  img.onerror = () => {
    console.warn(`Failed to load texture: ${path}`);
    // Leave the previous texture showing, or show the dark fallback
  };
  img.src = path;
}

function uploadTexture(img) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  // REPEAT on X (longitude wraps around), CLAMP on Y (poles don't wrap)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
}

// Load the first planet's texture
loadTexture(PLANETS[0].texture);

// ═══════════════════════════════════════════════════════════════
// FULL-SCREEN QUAD — we render everything in the fragment shader
// ═══════════════════════════════════════════════════════════════

const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

// ═══════════════════════════════════════════════════════════════
// SHADERS
// ═══════════════════════════════════════════════════════════════

// ── Vertex shader ──
// Just passes through the full-screen quad coordinates as UV
const VERT = `
attribute vec2 aPos;
varying vec2 vUV;
void main() {
  vUV = aPos;                       // vUV ranges from (-1,-1) to (1,1)
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

// ── Fragment shader ──
// This is where all the planet rendering happens:
//   1. Camera setup from orbit angles
//   2. Ray-sphere intersection to find the planet surface
//   3. Equirectangular texture lookup
//   4. Per-shader-type lighting (terrestrial, ocean, lava, gas, ice)
//   5. Atmosphere rim glow
//   6. Volumetric atmosphere scatter (6-step ray march)
//   7. Background stars
//   8. ACES tonemapping + vignette
const FRAG = `
precision highp float;
varying vec2 vUV;

// ── Uniforms ──
uniform vec2 uRes;        // Canvas resolution in pixels
uniform float uTime;      // Seconds since start
uniform float uRotX;      // Camera horizontal orbit angle
uniform float uRotY;      // Camera vertical orbit angle
uniform float uZoom;      // Camera distance
uniform sampler2D uTex;   // Planet surface texture (equirectangular)

// ── Per-planet uniforms ──
uniform int uShader;       // 0=terrestrial, 1=ocean, 2=lava, 3=gas, 4=ice
uniform vec3 uAtmosCol;    // Atmosphere color
uniform float uAtmosStr;   // Atmosphere intensity
uniform float uSpinRate;   // Rotation speed multiplier

// ═══════ Utility functions ═══════

// Rotation matrices — used for camera orbit and texture spin
mat3 rotY(float a) { float c=cos(a), s=sin(a); return mat3(c,0,s, 0,1,0, -s,0,c); }
mat3 rotX(float a) { float c=cos(a), s=sin(a); return mat3(1,0,0, 0,c,-s, 0,s,c); }

// Ray-sphere intersection (single hit — front face only)
// Returns distance to hit, or -1 if miss
float raySphere(vec3 ro, vec3 rd, float r) {
  float b = dot(ro, rd);
  float c = dot(ro, ro) - r * r;
  float d = b * b - c;
  if (d < 0.0) return -1.0;
  return -b - sqrt(d);
}

// Ray-sphere intersection (both entry and exit distances)
// Used for atmosphere volume rendering
vec2 raySphere2(vec3 ro, vec3 rd, float r) {
  float b = dot(ro, rd);
  float c = dot(ro, ro) - r * r;
  float d = b * b - c;
  if (d < 0.0) return vec2(-1.0);
  float sq = sqrt(d);
  return vec2(-b - sq, -b + sq);
}

// Equirectangular UV from a normal vector on the unit sphere
// Maps 3D direction → (u, v) where u=longitude, v=latitude
vec2 sphereUV(vec3 n) {
  float u = atan(n.z, n.x) / 6.28318 + 0.5;       // 0→1 around equator
  float v = asin(clamp(n.y, -1.0, 1.0)) / 3.14159 + 0.5; // 0→1 pole to pole
  return vec2(u, 1.0 - v);                          // Flip V (texture Y=0 is top)
}

// ACES filmic tonemapping — maps HDR colors to displayable range
vec3 aces(vec3 x) {
  return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}

// ═══════ Constants ═══════

// Sun/light direction — top-right-front
vec3 sunDir = normalize(vec3(1.0, 0.4, 0.6));

// ═══════ Main rendering ═══════

void main() {
  // ── Step 1: Screen UV with aspect correction ──
  vec2 uv = vUV;
  float aspect = uRes.x / uRes.y;
  uv.x *= aspect;

  // ── Step 2: Camera setup ──
  // Camera orbits around origin at distance uZoom
  // rotX = horizontal angle, rotY = vertical angle
  vec3 camPos = rotY(uRotX) * rotX(uRotY) * vec3(0.0, 0.0, uZoom);
  vec3 fwd = normalize(-camPos);                              // Look at origin
  vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));   // Camera right
  vec3 up = cross(right, fwd);                                // Camera up
  vec3 rd = normalize(fwd + uv.x * right + uv.y * up);       // Ray direction

  // ── Step 3: Ray-sphere intersection ──
  float hit = raySphere(camPos, rd, 1.0); // Unit sphere at origin
  vec3 col = vec3(0.0);

  // ── Step 4: Planet surface rendering ──
  if (hit > 0.0) {
    vec3 hitPos = camPos + rd * hit;
    vec3 normal = normalize(hitPos);
    vec3 viewDir = normalize(camPos - hitPos);

    // Spin the texture coordinates over time
    float spin = uTime * 0.012 * uSpinRate;
    vec3 texNormal = rotY(spin) * normal;
    vec2 texUV = sphereUV(texNormal);

    // Sample the planet texture
    vec3 surface = texture2D(uTex, texUV).rgb;

    // ── Lighting — varies by shader type ──
    float NdotL = dot(normal, sunDir);
    float lit = smoothstep(-0.08, 0.20, NdotL); // Soft terminator

    if (uShader == 0) {
      // ── TERRESTRIAL — directional light + optional specular on dark areas ──
      col = surface * (0.035 + lit * 0.95);
      // Specular highlight on dark (ocean-like) areas
      float brightness = dot(surface, vec3(0.3, 0.5, 0.2));
      float waterMask = 1.0 - smoothstep(0.05, 0.18, brightness);
      vec3 halfDir = normalize(sunDir + viewDir);
      float spec = pow(max(dot(normal, halfDir), 0.0), 60.0);
      col += vec3(1.0, 0.97, 0.90) * spec * 0.20 * lit * waterMask;

    } else if (uShader == 1) {
      // ── OCEAN — full-surface specular, everything is water ──
      col = surface * (0.035 + lit * 0.95);
      vec3 halfDir = normalize(sunDir + viewDir);
      float spec = pow(max(dot(normal, halfDir), 0.0), 60.0);
      col += vec3(1.0, 0.98, 0.92) * spec * 0.35 * lit;

    } else if (uShader == 2) {
      // ── LAVA — emissive glow from bright surface areas ──
      float glow = length(surface) / 1.73; // 0→1 based on pixel brightness
      col = surface * (0.04 + lit * 0.45) + surface * glow * 0.9;
      // Night side: lava still glows in the dark
      float nightGlow = smoothstep(0.1, -0.3, NdotL);
      col += surface * nightGlow * 0.45;

    } else if (uShader == 3) {
      // ── GAS GIANT — soft diffuse, no specular ──
      col = surface * (0.05 + lit * 0.90);

    } else if (uShader == 4) {
      // ── ICE — subtle specular, cool tones ──
      col = surface * (0.04 + lit * 0.92);
      vec3 halfDir = normalize(sunDir + viewDir);
      float spec = pow(max(dot(normal, halfDir), 0.0), 40.0);
      col += vec3(0.9, 0.95, 1.0) * spec * 0.15 * lit;
    }

    // ── Atmosphere rim glow ──
    // Fresnel-like effect: edge of sphere glows with atmosphere color
    float NdotV = max(dot(normal, viewDir), 0.0);
    float rim = pow(1.0 - NdotV, 4.5);
    col += uAtmosCol * rim * uAtmosStr * (0.25 + lit * 0.75);
  }

  // ── Step 5: Volumetric atmosphere scatter ──
  // Ray-march through a thin shell above the planet surface
  // Creates the haze/glow visible at the planet's edge
  {
    float atmosRadius = 1.06; // Atmosphere shell outer radius
    vec2 atmosHit = raySphere2(camPos, rd, atmosRadius);

    if (atmosHit.x > 0.0 || atmosHit.y > 0.0) {
      float marchStart = max(atmosHit.x, 0.0);
      float marchEnd = atmosHit.y;
      if (hit > 0.0) marchEnd = min(marchEnd, hit); // Stop at surface

      if (marchStart < marchEnd) {
        float stepSize = (marchEnd - marchStart) / 6.0; // 6 steps
        vec3 scatter = vec3(0.0);
        float opticalDepth = 0.0;

        for (int i = 0; i < 6; i++) {
          float t = marchStart + (float(i) + 0.5) * stepSize;
          vec3 samplePos = camPos + rd * t;
          float altitude = length(samplePos) - 1.0;           // Height above surface
          float density = exp(-altitude / 0.2) * stepSize * 4.0; // Exponential falloff
          opticalDepth += density;

          // How much sunlight reaches this point
          float sunVis = smoothstep(-0.1, 0.35, dot(normalize(samplePos), sunDir));
          scatter += uAtmosCol * density * sunVis * exp(-opticalDepth * 1.2);
        }

        col += scatter * 3.5 * uAtmosStr / 0.30; // Normalize to atmosStr
      }
    }
  }

  // ── Step 6: Background stars ──
  // Only drawn where the ray missed the planet
  // Two layers of procedural stars with twinkling
  if (hit < 0.0) {
    vec3 dir = normalize(rd);
    float theta = acos(clamp(dir.y, -1.0, 1.0));  // Polar angle
    float phi = atan(dir.z, dir.x);                // Azimuthal angle

    for (int layer = 0; layer < 2; layer++) {
      float fl = float(layer);
      float density = 140.0 + fl * 90.0;           // Grid density per layer
      vec2 grid = vec2(phi * density, theta * density);
      vec2 cellId = floor(grid);
      vec2 cellFrac = fract(grid) - 0.5;

      // Pseudo-random hash per cell
      float hash = fract(sin(dot(cellId + fl * 50.0, vec2(127.1, 311.7))) * 43758.5453);

      if (hash > 0.97) { // ~3% of cells have a star
        // Random offset within cell (so stars aren't on a grid)
        vec2 starOff = vec2(
          fract(sin(dot(cellId + fl * 50.0, vec2(269.5, 183.3))) * 43758.5453),
          fract(sin(dot(cellId + fl * 50.0, vec2(419.2, 371.9))) * 43758.5453)
        ) - 0.5;

        float dist = length(cellFrac - starOff * 0.5);
        float brightness = (hash - 0.97) / 0.03;                              // 0→1
        float twinkle = 0.7 + 0.3 * sin(uTime * (1.0 + hash * 3.0) + hash * 99.0);
        vec3 starCol = mix(vec3(0.6, 0.7, 1.0), vec3(1.0, 0.9, 0.7), fract(hash * 7.0));

        col += starCol * exp(-dist * dist * 1200.0) * brightness * twinkle
               * (1.0 - fl * 0.35) * 0.3;
      }
    }
  }

  // ── Step 7: Post-processing ──
  col = aces(col * 1.2);                                    // Tonemapping
  col *= 1.0 - 0.18 * dot(vUV * 0.5, vUV * 0.5);           // Vignette
  col = pow(col, vec3(0.97));                                // Gamma nudge
  gl_FragColor = vec4(col, 1.0);
}
`;

// ═══════════════════════════════════════════════════════════════
// SHADER COMPILATION
// ═══════════════════════════════════════════════════════════════

function makeShader(type, source) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, source);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(sh));
    return null;
  }
  return sh;
}

function makeProgram(vsSrc, fsSrc) {
  const vs = makeShader(gl.VERTEX_SHADER, vsSrc);
  const fs = makeShader(gl.FRAGMENT_SHADER, fsSrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error('Shader link error:', gl.getProgramInfoLog(prog));
    return null;
  }
  return prog;
}

const prog = makeProgram(VERT, FRAG);
gl.useProgram(prog);

// ── Bind the full-screen quad ──
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// ── Get uniform locations ──
const uRes       = gl.getUniformLocation(prog, 'uRes');
const uTime      = gl.getUniformLocation(prog, 'uTime');
const uRotXLoc   = gl.getUniformLocation(prog, 'uRotX');
const uRotYLoc   = gl.getUniformLocation(prog, 'uRotY');
const uZoomLoc   = gl.getUniformLocation(prog, 'uZoom');
const uTexLoc    = gl.getUniformLocation(prog, 'uTex');
const uShaderLoc = gl.getUniformLocation(prog, 'uShader');
const uAtmosCol  = gl.getUniformLocation(prog, 'uAtmosCol');
const uAtmosStr  = gl.getUniformLocation(prog, 'uAtmosStr');
const uSpinRate  = gl.getUniformLocation(prog, 'uSpinRate');

// Bind texture unit 0
gl.uniform1i(uTexLoc, 0);

// ═══════════════════════════════════════════════════════════════
// SHADER TYPE → INTEGER MAPPING
// Must match the if/else chain in the fragment shader
// ═══════════════════════════════════════════════════════════════

const SHADER_TYPES = {
  terrestrial: 0,
  ocean: 1,
  lava: 2,
  gas: 3,
  ice: 4,
};

// ═══════════════════════════════════════════════════════════════
// RENDER LOOP
// ═══════════════════════════════════════════════════════════════

const startTime = performance.now();

(function renderLoop() {
  const t = (performance.now() - startTime) / 1000.0;

  // Auto-rotate when not dragging
  if (!dragging) rotX += 0.0006;

  // Get current planet config
  const planet = PLANETS[currentPlanetIdx];
  const shaderType = SHADER_TYPES[planet.shader] || 0;

  // ── Upload uniforms ──
  gl.uniform2f(uRes, cv.width, cv.height);
  gl.uniform1f(uTime, t);
  gl.uniform1f(uRotXLoc, rotX);
  gl.uniform1f(uRotYLoc, rotY);
  gl.uniform1f(uZoomLoc, zoom);
  gl.uniform1i(uShaderLoc, shaderType);
  gl.uniform3f(uAtmosCol, planet.atmos[0], planet.atmos[1], planet.atmos[2]);
  gl.uniform1f(uAtmosStr, planet.atmosStr);
  gl.uniform1f(uSpinRate, planet.spinRate);

  // ── Draw ──
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  requestAnimationFrame(renderLoop);
})();
</script>
</body>
</html>
