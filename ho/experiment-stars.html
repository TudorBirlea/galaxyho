<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Star Shader Experiment</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; width: 100vw; height: 100vh;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; }
canvas { display: block; width: 100%; height: 100%; }

#bottom-ui {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; flex-direction: column; align-items: center; gap: 10px;
  z-index: 10; max-width: 90vw;
}
#enhancements, #controls {
  display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;
}
.star-btn {
  padding: 6px 14px; border: 1px solid rgba(255,255,255,0.15);
  background: rgba(0,0,0,0.6); color: rgba(255,255,255,0.7);
  font-family: inherit; font-size: 11px; letter-spacing: 1px;
  cursor: pointer; border-radius: 4px; transition: all 0.3s;
  text-transform: uppercase; backdrop-filter: blur(8px);
}
.star-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
.star-btn.active { border-color: rgba(255,200,100,0.6); color: #ffd080; background: rgba(255,200,100,0.08); }
.enh-btn {
  padding: 5px 12px; border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.4);
  font-family: inherit; font-size: 10px; letter-spacing: 0.8px;
  cursor: pointer; border-radius: 4px; transition: all 0.3s;
  backdrop-filter: blur(8px);
}
.enh-btn:hover { background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.7); }
.enh-btn.on { border-color: rgba(100,200,150,0.5); color: rgba(100,200,150,0.8); background: rgba(100,200,150,0.06); }

#info-panel {
  position: fixed; top: 24px; left: 24px; z-index: 10;
  color: rgba(255,255,255,0.5); font-size: 11px; letter-spacing: 1px; line-height: 1.8;
}
#info-panel .label { color: rgba(255,255,255,0.3); }
#info-panel .value { color: rgba(255,200,150,0.8); }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="info-panel">
  <div><span class="label">STAR </span><span class="value" id="star-name">The Sun (Sol)</span></div>
  <div><span class="label">TEMP </span><span class="value" id="star-temp">5,778 K</span></div>
  <div><span class="label">CLASS </span><span class="value" id="star-class">G2V</span></div>
</div>

<div id="bottom-ui">
  <div id="enhancements">
    <button class="enh-btn" data-enh="voronoi">Voronoi Cells</button>
    <button class="enh-btn" data-enh="prominences">Prominences</button>
    <button class="enh-btn" data-enh="diffrot">Diff. Rotation</button>
    <button class="enh-btn" data-enh="corona">Enhanced Corona</button>
    <button class="enh-btn" data-enh="active">Active Regions</button>
  </div>
  <div id="controls">
    <button class="star-btn active" data-star="sun">Sol · G2V</button>
    <button class="star-btn" data-star="red">Betelgeuse · M1</button>
    <button class="star-btn" data-star="orange">Arcturus · K1.5</button>
    <button class="star-btn" data-star="yellow">Procyon · F5</button>
    <button class="star-btn" data-star="white">Sirius · A1V</button>
    <button class="star-btn" data-star="blue">Rigel · B8</button>
    <button class="star-btn" data-star="hot">Naos · O5</button>
  </div>
</div>

<script>
// ─── Star definitions ───────────────────────────────────────
const STARS = {
  // EUV-inspired tint colors (from GOES-16 SUVI wavelengths)
  sun:    { name: 'The Sun (Sol)',     temp: 5778,  cls: 'G2V',    spots: 1.0, granuleScale: 1.0, color: [1.0, 0.72, 0.18] },    // 171Å golden
  red:    { name: 'Betelgeuse',        temp: 3500,  cls: 'M1Iab',  spots: 0.3, granuleScale: 0.6, color: [1.0, 0.22, 0.06] },    // 304Å deep red
  orange: { name: 'Arcturus',          temp: 4286,  cls: 'K1.5III', spots: 0.5, granuleScale: 0.8, color: [1.0, 0.45, 0.10] },   // 195Å amber
  yellow: { name: 'Procyon A',         temp: 6530,  cls: 'F5IV-V', spots: 0.8, granuleScale: 1.1, color: [0.95, 0.80, 0.22] },   // warm gold
  white:  { name: 'Sirius A',          temp: 9940,  cls: 'A1V',    spots: 0.1, granuleScale: 1.4, color: [0.25, 0.75, 0.65] },   // 94Å teal
  blue:   { name: 'Rigel',             temp: 12100, cls: 'B8Ia',   spots: 0.05, granuleScale: 1.6, color: [0.12, 0.28, 1.0] },   // 284Å blue
  hot:    { name: 'Naos (Zeta Puppis)', temp: 35000, cls: 'O5Iaf', spots: 0.02, granuleScale: 1.8, color: [0.18, 0.85, 1.0] },  // 131Å cyan
};

let currentStar = STARS.sun;
let targetTemp = currentStar.temp, currentTemp = currentStar.temp;
let targetSpots = currentStar.spots, currentSpots = currentStar.spots;
let targetGranule = currentStar.granuleScale, currentGranule = currentStar.granuleScale;
let targetColor = [...currentStar.color], currentColor = [...currentStar.color];

// Enhancement states
const enhancements = { voronoi: 0, prominences: 0, diffrot: 0, corona: 0, active: 0 };

// ─── UI ─────────────────────────────────────────────────────
document.querySelectorAll('.star-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.star-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const s = STARS[btn.dataset.star];
    currentStar = s;
    targetTemp = s.temp; targetSpots = s.spots; targetGranule = s.granuleScale; targetColor = [...s.color];
    document.getElementById('star-name').textContent = s.name;
    document.getElementById('star-temp').textContent = s.temp.toLocaleString() + ' K';
    document.getElementById('star-class').textContent = s.cls;
  });
});

document.querySelectorAll('.enh-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const key = btn.dataset.enh;
    enhancements[key] = enhancements[key] ? 0 : 1;
    btn.classList.toggle('on', !!enhancements[key]);
  });
});

// ─── WebGL setup ────────────────────────────────────────────
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, alpha: false });

function resize() {
  const dpr = Math.min(window.devicePixelRatio, 2);
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// ─── Mouse ──────────────────────────────────────────────────
let rotX = 0.0, rotY = 0.0, zoomDist = 5.0;
let dragging = false, lastMX = 0, lastMY = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  rotX += (e.clientX - lastMX) * 0.005;
  rotY += (e.clientY - lastMY) * 0.005;
  rotY = Math.max(-1.5, Math.min(1.5, rotY));
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
  zoomDist *= e.deltaY > 0 ? 1.06 : 0.94;
  zoomDist = Math.max(1.3, Math.min(12.0, zoomDist));
}, { passive: true });

canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!dragging) return;
  rotX += (e.touches[0].clientX - lastMX) * 0.005;
  rotY += (e.touches[0].clientY - lastMY) * 0.005;
  rotY = Math.max(-1.5, Math.min(1.5, rotY));
  lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', () => dragging = false);

// ─── Shader helpers ─────────────────────────────────────────
function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(s));
    gl.deleteShader(s); return null;
  }
  return s;
}
function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(p)); return null;
  }
  return p;
}

// ─── Quad ───────────────────────────────────────────────────
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

// ─── Vertex shader ──────────────────────────────────────────
const vertSrc = `
attribute vec2 aPos;
varying vec2 vUV;
void main() { vUV = aPos; gl_Position = vec4(aPos, 0.0, 1.0); }`;

// ─── Fragment shader ────────────────────────────────────────
const fragSrc = `
precision highp float;
varying vec2 vUV;

uniform vec2 uResolution;
uniform float uTime;
uniform float uRotX, uRotY, uZoom;
uniform float uHighTemp, uSpotAmount, uGranuleScale;
uniform vec3 uStarColor;
// Enhancement toggles
uniform float uVoronoi, uProminences, uDiffRot, uCorona, uActive;
// Planet
uniform vec3 uPlanetPos;
uniform float uPlanetRadius;

// ── ACES ──
vec3 ACESFilm(vec3 x) {
  return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14), 0.0, 1.0);
}

// ── 3D Simplex noise (Ashima) ──
vec3 mod289v3(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }
vec4 mod289v4(vec4 x) { return x - floor(x*(1.0/289.0))*289.0; }
vec4 permute(vec4 x) { return mod289v4(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314*r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289v3(i);
  vec4 p = permute(permute(permute(
    i.z + vec4(0.0, i1.z, i2.z, 1.0))
    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0*floor(p*ns.z*ns.z);
  vec4 x_ = floor(j*ns.z);
  vec4 y_ = floor(j - 7.0*x_);
  vec4 x = x_*ns.x + ns.yyyy;
  vec4 y = y_*ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);
  m = m*m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}

float fbm(vec3 p, float freq, int octaves) {
  float sum = 0.0, amp = 1.0, f = freq;
  for (int i = 0; i < 8; i++) {
    if (i >= octaves) break;
    sum += snoise(p*f)*amp;
    f *= 2.0; amp *= 0.5;
  }
  return sum;
}

// ── 3D Voronoi ──
vec3 hash33(vec3 p) {
  p = vec3(dot(p,vec3(127.1,311.7,74.7)),
           dot(p,vec3(269.5,183.3,246.1)),
           dot(p,vec3(113.5,271.9,124.6)));
  return fract(sin(p)*43758.5453);
}

float voronoi3D(vec3 p) {
  vec3 ip = floor(p);
  vec3 fp = fract(p);
  float d1 = 10.0, d2 = 10.0;
  for (int x = -1; x <= 1; x++)
  for (int y = -1; y <= 1; y++)
  for (int z = -1; z <= 1; z++) {
    vec3 nb = vec3(float(x), float(y), float(z));
    vec3 pt = hash33(ip + nb);
    vec3 diff = nb + pt - fp;
    float d = dot(diff, diff);
    if (d < d1) { d2 = d1; d1 = d; } else if (d < d2) { d2 = d; }
  }
  return sqrt(d1);
}

// ── Black-body → RGB ──
vec3 tempToColor(float tempK) {
  float t = clamp(tempK, 1000.0, 40000.0) / 100.0;
  float r, g, b;
  if (t <= 66.0) r = 255.0; else r = 329.698727446*pow(t-60.0, -0.1332047592);
  if (t <= 66.0) g = 99.4708025861*log(t) - 161.1195681661;
  else g = 288.1221695283*pow(t-60.0, -0.0755148492);
  if (t >= 66.0) b = 255.0; else if (t <= 19.0) b = 0.0;
  else b = 138.5177312231*log(t-10.0) - 305.0447927307;
  return clamp(vec3(r, g, b)/255.0, 0.0, 1.0);
}

// ── EUV-inspired color grading ──
// Replaces blackbody white with vivid spectral-class tint
// Preserves luminance variation while shifting hue
vec3 colorGrade(vec3 baseCol, vec3 tint, float intensity) {
  float lum = dot(baseCol, vec3(0.2126, 0.7152, 0.0722));
  // Hot (bright) areas: let some white through; dim areas: full tint
  vec3 tinted = tint * (lum * 2.8 + 0.04);
  float blend = intensity * (1.0 - lum * 0.35); // less tint on brightest spots
  return mix(baseCol, tinted, blend);
}

// ── Rotation ──
mat3 rotY(float a) { float c=cos(a),s=sin(a); return mat3(c,0,s, 0,1,0, -s,0,c); }
mat3 rotX(float a) { float c=cos(a),s=sin(a); return mat3(1,0,0, 0,c,-s, 0,s,c); }

// ── Ray-sphere ──
float raySphere(vec3 ro, vec3 rd, float radius) {
  float b = dot(ro, rd);
  float c = dot(ro, ro) - radius*radius;
  float disc = b*b - c;
  if (disc < 0.0) return -1.0;
  return -b - sqrt(disc);
}

// ── Ray-sphere at offset center ──
float raySphereAt(vec3 ro, vec3 rd, vec3 center, float radius) {
  vec3 oc = ro - center;
  float b = dot(oc, rd);
  float c = dot(oc, oc) - radius*radius;
  float disc = b*b - c;
  if (disc < 0.0) return -1.0;
  return -b - sqrt(disc);
}

// ── Planet surface renderer ──
vec3 renderPlanet(vec3 hitPos, vec3 center, vec3 camP, float time) {
  vec3 normal = normalize(hitPos - center);
  vec3 L = normalize(-center);   // light from star at origin
  vec3 V = normalize(camP - hitPos);

  // Spin rotation
  float spinAngle = time * 0.08;
  float rc = cos(spinAngle), rs = sin(spinAngle);
  vec3 spun = vec3(rc*normal.x + rs*normal.z, normal.y, -rs*normal.x + rc*normal.z);
  vec3 nn = spun * 3.5;

  // Continents via noise
  float land = fbm(nn, 2.0, 4);
  float isLand = smoothstep(-0.1, 0.15, land);
  vec3 oceanCol = vec3(0.04, 0.08, 0.22);
  vec3 landCol = mix(vec3(0.12, 0.30, 0.08), vec3(0.50, 0.40, 0.22), smoothstep(0.15, 0.5, land));
  vec3 surface = mix(oceanCol, landCol, isLand);

  // Clouds
  float clouds = fbm(nn + vec3(time*0.008, 0., time*0.005), 2.8, 4);
  clouds = smoothstep(0.05, 0.50, clouds);
  surface = mix(surface, vec3(0.92, 0.94, 0.98), clouds * 0.5);

  // Polar caps
  float polar = smoothstep(0.70, 0.90, abs(spun.y) + fbm(nn, 3.0, 3)*0.08);
  surface = mix(surface, vec3(0.88, 0.91, 0.95), polar * 0.6);

  // Lighting
  float NdL = dot(normal, L);
  float lit = smoothstep(-0.08, 0.20, NdL);

  // Star-colored light tint
  vec3 starTint = mix(vec3(1.0), uStarColor * 1.5 + 0.5, 0.25);
  vec3 col = surface * (0.015 + lit * 0.45) * starTint;

  // Water specular
  vec3 halfDir = normalize(L + V);
  float spec = pow(max(dot(normal, halfDir), 0.0), 60.0);
  col += vec3(1.0, 0.97, 0.90) * spec * 0.15 * lit * (1.0 - isLand);

  // Atmosphere rim glow
  float NdV = max(dot(normal, V), 0.0);
  float rim = pow(1.0 - NdV, 4.0);
  col += vec3(0.30, 0.50, 1.00) * rim * 0.30 * (0.15 + lit * 0.50);

  return col;
}

void main() {
  vec2 uv = vUV;
  float aspect = uResolution.x / uResolution.y;
  uv.x *= aspect;

  // Camera
  vec3 camPos = rotY(uRotX) * rotX(uRotY) * vec3(0.0, 0.0, uZoom);
  vec3 fwd = normalize(-camPos);
  vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, fwd);
  vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

  vec3 col = vec3(0.0);
  float hit = raySphere(camPos, rd, 1.0);
  float slowTime = uTime * 0.04;

  // Planet hit test
  float tPlanet = uPlanetRadius > 0.0 ? raySphereAt(camPos, rd, uPlanetPos, uPlanetRadius) : -1.0;
  bool planetVis = tPlanet > 0.0 && (hit < 0.0 || tPlanet < hit);

  // Corona geometry (needed for glow + star masking)
  float b_cor = dot(camPos, rd);
  float closestDist = length(camPos + rd * max(-b_cor, 0.0));
  float edgeDist = max(0.0, closestDist - 1.0);

  // ── Star surface ──
  if (hit > 0.0 && !planetVis) {
    vec3 hitPos = camPos + rd * hit;
    vec3 normal = normalize(hitPos);

    // Surface coordinate with optional differential rotation
    vec3 surfCoord;
    if (uDiffRot > 0.5) {
      float lat = asin(clamp(normal.y, -1.0, 1.0));
      float lonShift = slowTime * (0.3 + 0.18 * cos(lat * 1.5));
      float c = cos(lonShift), s = sin(lonShift);
      surfCoord = vec3(c*normal.x + s*normal.z, normal.y, -s*normal.x + c*normal.z);
    } else {
      surfCoord = rotY(slowTime * 0.3) * normal;
    }

    float gScale = 5.0 * uGranuleScale;

    // Layer 1: Granulation
    float granuleNoise;
    if (uVoronoi > 0.5) {
      // Voronoi cellular convection
      float cell = voronoi3D(surfCoord * gScale * 0.6);
      float cellPattern = 1.0 - smoothstep(0.0, 0.22, cell);
      // Blend with subtle FBM for organic feel
      float detail = (fbm(surfCoord, gScale, 3) + 1.0) * 0.5;
      granuleNoise = cellPattern * 0.7 + detail * 0.3;
    } else {
      granuleNoise = (fbm(surfCoord, gScale, 4) + 1.0) * 0.5;
    }

    // Layer 2: Sunspots — deeper, higher contrast
    float spotFreq = gScale * 0.15;
    float spotNoise = snoise(surfCoord * spotFreq + vec3(slowTime*0.1, 0.0, slowTime*0.05));
    float sunspots = max(0.0, spotNoise*3.2 - 2.1) * uSpotAmount;

    // Layer 3: Bright regions — more intense
    float brightFreq = gScale * 0.08;
    float brightNoise = snoise(surfCoord * brightFreq + vec3(0.0, slowTime*0.15, 0.0));
    float brightSpot = max(0.0, brightNoise*1.8 - 1.0);

    // Layer 4: Active region flashes (optional)
    float activeFlash = 0.0;
    if (uActive > 0.5) {
      float flashFreq = gScale * 0.2;
      float flashBase = snoise(surfCoord * flashFreq + vec3(uTime*0.15, 0.0, 0.0));
      float flashPulse = sin(uTime * 2.5 + flashBase * 12.0) * 0.5 + 0.5;
      float spotProximity = smoothstep(0.15, 0.5, sunspots / max(uSpotAmount, 0.01));
      activeFlash = flashPulse * spotProximity * 0.35;
      // Additional random bright flare events
      float flareNoise = snoise(surfCoord * 2.0 + vec3(0.0, uTime * 0.3, 0.0));
      float flare = max(0.0, flareNoise * 3.0 - 2.4);
      activeFlash += flare * 0.2 * (0.5 + 0.5 * sin(uTime * 4.0 + flareNoise * 20.0));
    }

    // Combine with contrast curve
    float total = clamp(granuleNoise - sunspots + brightSpot + activeFlash, 0.0, 1.5);
    total = pow(total, 1.25); // push darks darker, brights brighter

    float highTemp = uHighTemp;
    float lowTemp = highTemp * 0.12; // much darker base → higher contrast
    float pixelTemp = mix(lowTemp, highTemp, total);
    vec3 starCol = tempToColor(pixelTemp);

    // Limb darkening — stronger for more dramatic edge
    float NdotV = max(dot(normal, normalize(camPos - hitPos)), 0.0);
    float limb = pow(NdotV, 0.5);
    float limbTemp = mix(lowTemp*1.2, pixelTemp, pow(NdotV, 0.55));
    vec3 limbCol = tempToColor(limbTemp);
    starCol = mix(limbCol, starCol, pow(NdotV, 0.35));
    starCol *= limb;

    // Brightness boost
    float brightnessBoost = 1.2 + clamp((highTemp - 4000.0)/15000.0, 0.0, 1.0) * 0.6;
    starCol *= brightnessBoost;

    // EUV color grading — vivid spectral tint instead of blackbody white
    starCol = colorGrade(starCol, uStarColor, 0.88);

    // Re-saturate after grading (boost color vibrancy)
    float postLum = dot(starCol, vec3(0.2126, 0.7152, 0.0722));
    starCol = mix(vec3(postLum), starCol, 1.4);
    starCol = max(starCol, vec3(0.0));

    col = starCol;
  }

  // ── Planet surface ──
  if (planetVis) {
    vec3 pH = camPos + rd * tPlanet;
    col = renderPlanet(pH, uPlanetPos, camPos, uTime);
  }

  // ── Corona glow computation ──
  float totalGlow;
  vec3 glowColor = colorGrade(tempToColor(uHighTemp), uStarColor, 0.75);

  if (uCorona > 0.5) {
    // Enhanced multi-layer corona
    float glow1 = exp(-edgeDist * 7.0) * 0.50;    // tight inner
    float glow2 = exp(-edgeDist * 2.5) * 0.10;    // medium halo
    float glow3 = exp(-edgeDist * 0.7) * 0.018;   // wide diffuse
    float coronaBoost = 1.0 + clamp((uHighTemp - 4000.0)/20000.0, 0.0, 0.4);
    totalGlow = (glow1 + glow2 + glow3) * coronaBoost;

    // Coronal streamers — directional asymmetry
    vec3 closestOnSphere = normalize(camPos + rd * max(-b_cor, 0.0));
    float streamerNoise = snoise(closestOnSphere * 3.0 + vec3(0.0, slowTime * 0.05, 0.0));
    float streamer = max(0.0, streamerNoise * 1.5 - 0.3) * exp(-edgeDist * 3.0) * 0.12;
    totalGlow += streamer;
  } else {
    // Basic corona (single layer)
    float glow1 = exp(-edgeDist * 5.0) * 0.35;
    float coronaBoost = 1.0 + clamp((uHighTemp - 4000.0)/20000.0, 0.0, 0.3);
    totalGlow = glow1 * coronaBoost;
  }

  // ── Background stars (rendered before corona overlay) ──
  if (hit < 0.0 && !planetVis) {
    vec3 d = normalize(rd);
    float theta = acos(clamp(d.y, -1.0, 1.0));
    float phi = atan(d.z, d.x);
    float glowMask = 1.0 - clamp(totalGlow * 4.0, 0.0, 1.0);

    for (int layer = 0; layer < 3; layer++) {
      float fl = float(layer);
      float density = 120.0 + fl*80.0;
      vec2 grid = vec2(phi*density, theta*density);
      vec2 cellId = floor(grid);
      vec2 cellUV = fract(grid) - 0.5;
      float h = fract(sin(dot(cellId + fl*50.0, vec2(127.1,311.7)))*43758.5453);
      float threshold = 0.96 + fl*0.015;
      if (h > threshold) {
        vec2 starOff = vec2(
          fract(sin(dot(cellId + fl*50.0, vec2(269.5,183.3)))*43758.5453),
          fract(sin(dot(cellId + fl*50.0, vec2(419.2,371.9)))*43758.5453)
        ) - 0.5;
        float dist = length(cellUV - starOff*0.6);
        float brightness = (h - threshold) / (1.0 - threshold);
        float twinkle = 0.7 + 0.3*sin(uTime*(1.0 + h*3.0) + h*100.0);
        float point = exp(-dist*dist*800.0) * brightness * twinkle;
        vec3 sCol = mix(vec3(0.6,0.7,1.0), vec3(1.0,0.85,0.7), fract(h*7.0));
        float dimmer = 1.0 - fl*0.3;
        col += sCol * point * dimmer * 0.5 * glowMask;
      }
    }
  }

  // ── Corona overlay (skip for planet pixels) ──
  if (!planetVis) {
    float whiteness = exp(-edgeDist * 3.0);
    vec3 gc = mix(glowColor, vec3(1.0), whiteness * 0.5);
    col += gc * totalGlow;
  }

  // ── Prominences (optional) ──
  if (uProminences > 0.5 && !planetVis && hit < 0.0 && edgeDist < 0.6) {
    vec3 closestPoint = camPos + rd * max(-b_cor, 0.0);
    vec3 surfPoint = normalize(closestPoint);

    // Sample active regions on the surface nearest to this ray
    vec3 promCoord = rotY(slowTime * 0.15) * surfPoint;
    float promNoise = snoise(promCoord * 2.5) * 0.55 + snoise(promCoord * 5.0) * 0.3;
    float promActive = smoothstep(0.2, 0.55, promNoise);

    // Prominence height varies per region
    float promHeight = promActive * (0.15 + 0.25 * max(0.0, snoise(promCoord * 1.2)));

    if (promHeight > 0.01) {
      // Arc shape: peaks at mid-height
      float normH = clamp(edgeDist / promHeight, 0.0, 1.0);
      float arcShape = sin(normH * 3.14159) * (1.0 - normH * 0.4);

      // Lateral variation — prominence isn't uniform around the limb
      float lateral = snoise(promCoord * 8.0 + vec3(slowTime * 0.1));
      float lateralMask = smoothstep(-0.2, 0.3, lateral);

      float promGlow = promActive * arcShape * lateralMask * exp(-edgeDist * 5.0);

      // Prominence color: tinted base, cooler orange/red at tip
      vec3 promBaseCol = colorGrade(tempToColor(uHighTemp * 0.8), uStarColor, 0.7);
      vec3 promTipCol = mix(uStarColor * 0.6, vec3(1.0, 0.5, 0.2), 0.4);
      vec3 promColor = mix(promBaseCol, promTipCol, normH * 0.7);

      col += promColor * promGlow * 0.7;
    }
  }

  // ── Tonemapping ──
  col = ACESFilm(col * 1.5);
  float vig = 1.0 - 0.3 * dot(vUV*0.5, vUV*0.5);
  col *= vig;
  col = pow(col, vec3(0.95));

  gl_FragColor = vec4(col, 1.0);
}
`;

// ─── Build ──────────────────────────────────────────────────
const vs = createShader(gl.VERTEX_SHADER, vertSrc);
const fs = createShader(gl.FRAGMENT_SHADER, fragSrc);
const prog = createProgram(vs, fs);

const aPos = gl.getAttribLocation(prog, 'aPos');
const uRes = gl.getUniformLocation(prog, 'uResolution');
const uTime = gl.getUniformLocation(prog, 'uTime');
const uRotXU = gl.getUniformLocation(prog, 'uRotX');
const uRotYU = gl.getUniformLocation(prog, 'uRotY');
const uZoomU = gl.getUniformLocation(prog, 'uZoom');
const uHighTempU = gl.getUniformLocation(prog, 'uHighTemp');
const uSpotU = gl.getUniformLocation(prog, 'uSpotAmount');
const uGranU = gl.getUniformLocation(prog, 'uGranuleScale');
const uStarColorU = gl.getUniformLocation(prog, 'uStarColor');
// Enhancement uniforms
const uVoronoiU = gl.getUniformLocation(prog, 'uVoronoi');
const uPromU = gl.getUniformLocation(prog, 'uProminences');
const uDiffRotU = gl.getUniformLocation(prog, 'uDiffRot');
const uCoronaU = gl.getUniformLocation(prog, 'uCorona');
const uActiveU = gl.getUniformLocation(prog, 'uActive');
// Planet uniforms
const uPlanetPosU = gl.getUniformLocation(prog, 'uPlanetPos');
const uPlanetRadU = gl.getUniformLocation(prog, 'uPlanetRadius');

gl.useProgram(prog);
gl.enableVertexAttribArray(aPos);
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// ─── Render ─────────────────────────────────────────────────
const t0 = performance.now();

function render() {
  const t = (performance.now() - t0) / 1000.0;

  // Smooth transitions
  currentTemp += (targetTemp - currentTemp) * 0.03;
  currentSpots += (targetSpots - currentSpots) * 0.03;
  currentGranule += (targetGranule - currentGranule) * 0.03;
  for (let i = 0; i < 3; i++) currentColor[i] += (targetColor[i] - currentColor[i]) * 0.03;

  if (!dragging) rotX += 0.001;

  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform1f(uTime, t);
  gl.uniform1f(uRotXU, rotX);
  gl.uniform1f(uRotYU, rotY);
  gl.uniform1f(uZoomU, zoomDist);
  gl.uniform1f(uHighTempU, currentTemp);
  gl.uniform1f(uSpotU, currentSpots);
  gl.uniform1f(uGranU, currentGranule);
  gl.uniform3f(uStarColorU, currentColor[0], currentColor[1], currentColor[2]);
  // Enhancement uniforms
  gl.uniform1f(uVoronoiU, enhancements.voronoi);
  gl.uniform1f(uPromU, enhancements.prominences);
  gl.uniform1f(uDiffRotU, enhancements.diffrot);
  gl.uniform1f(uCoronaU, enhancements.corona);
  gl.uniform1f(uActiveU, enhancements.active);

  // Planet orbit
  const planetAngle = t * 0.25;
  const planetOrbitR = 3.5;
  gl.uniform3f(uPlanetPosU,
    Math.cos(planetAngle) * planetOrbitR,
    Math.sin(planetAngle * 0.7) * 0.25,
    Math.sin(planetAngle) * planetOrbitR);
  gl.uniform1f(uPlanetRadU, 0.12);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
